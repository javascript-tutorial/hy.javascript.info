# Համեմատություններ

Մենք գիտենք համեմատության բազմաթիվ գործողություններ մաթեմատիկայից։

JavaScript-ում դրանք գրվում են հետևյալ տեսքով․

<<<<<<< HEAD
- Մեծ/փոքր։ <code>a &gt; b</code>, <code>a &lt; b</code>։- Մեծ/փոքր։ <code>a &gt; b</code>, <code>a &lt; b</code>։
- Մեծ/փոքր կամ հավասար։ <code>a &gt;= b</code>, <code>a &lt;= b</code>։
- Հավասար՝ `a == b`: Ուշադրություն դարձրեք, որ `==` գործողությունով ստուգվում է հավասարությունը, մինչդեռ `a = b` նշանակում է վերագրում։
- Ոչ հավասար։ Մաթեմատիկայում այս նշանը հետևյալն է՝ <code>&ne;</code>, բայց JavaScript-ում այն ներկայացվում է հետևյալ տեսքով՝ <code>a != b</code>։
=======
- Greater/less than: <code>a &gt; b</code>, <code>a &lt; b</code>.
- Greater/less than or equals: <code>a &gt;= b</code>, <code>a &lt;= b</code>.
- Equals: `a == b`, please note the double equality sign `==` means the equality test, while a single one `a = b` means an assignment.
- Not equals: In maths the notation is <code>&ne;</code>, but in JavaScript it's written as <code>a != b</code>.
>>>>>>> 3c934b5a46a76861255e3a4f29da6fd54ab05c8c

Այս հոդվածում մենք կսովորենք համեմատության տարբեր գործողությունները, թե ինչպես է JavaScript-ը կատարում դրանք, ներառյալ կարևոր առանձնահատկությունները։

Վերջում դուք կիմանաք, թե ինչպես խուսափել «JavaScript-ի տարօրիանկություններ»-ի հետ կապված խնդիրներից։

## Արդյունքը տրամաբանական տիպի է

Համեմատության բոլոր գործողությունները վերադարձնում են տրամաբանական տիպի արժեք․

- `true` - նշանակում է "այո", "ճիշտ" կամ "իրական".
- `false` - նշանակում է "ոչ", "սխալ" կամ "ոչ իրական/կեղծ". Օրինակ․

Օրինակ՝

```js run
alert( 2 > 1 );  // true (ճիշտ)
alert( 2 == 1 ); // false (սխալ)
alert( 2 != 1 ); // true (ճիշտ)
```

Համեմատության արդյունքը կարելի է վերագրել փոփոխականի, ինչպես ցանկացած արժեք․

```js run
let result = 5 > 4; // վերագրել համեմատության արդյունքը
alert(result); // true (ճիշտ)
```

## Տողերի համեմատություն

Եթե ցանկանում ենք ստուգել թե որ տողային փոփոխականն է մեծ, JavaScript-ը օգտագործում է այսպես կոչված "բառարան" (անգլ․՝ dictionary) կամ "բառարանային" (անգլ․՝ lexicographical) հերթականություն։

Այլ կերպ ասած՝ տողերը համեմատվում են տառ առ տառ։

Օրինակ՝

```js run
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

Երկու տողային փոփոխականների համեմատման ալգորիթմը շատ պարզ է․

1. Համեմատել երկու տողերի առաջին նշանները:
2․ Եթե առաջին տողի առաջին նշանը մեծ (կամ փոքր) է, քան մյուս տողինը, ապա առաջին տողը մեծ (կամ փոքր) է երկրորդից:
3. Հակառակ դեպքում, եթե տողերի առաջին նշանները հավասար են, ապա նույն ձևով համեմատվում են երկրորդ նշանները:
4. Գործողությունը կրկնվում է մինչև տողերից որևէ մեկի ավարտը։
5. Եթե տողերն ունեն նույն երկարությունը, ապա դրանք հավասար են։ Հակառակ դեպքում, մեծ երկարություն ունեցող տողը համարվում է ավելի մեծ:

Առաջին օրինակում `'Z' > 'A'` համեմատության արդյունքը կստացվի առաջին քայլից։

Երկրորդ համեմատությունը `'Glow'` և `'Glee'`, պահանջում է ավել քայլեր, քանի որ տողերը համեմատվում են նիշ առ նիշ․

1. `G`-ն նույնն է ինչ `G`-ն։
2. `l`-ը նույնն է ինչ `l`-ը։
3. `o`-ն մեծ է քան `e`-ն։ Այստեղ համեմատթույունն ավարտվում է, քանի որ առաջին տողը ավելի մեծ է, քան երկրորդը։

```smart header="Ոչ իրական բառարան, այլ Unicode-ային հերթականություն"
Վերևում բերված համեմատության ալգորիթմը մոտավորապես համարժեք է բառարաններում կամ հեռախոսագրքերում օգտագործվողին, բայց նույնը չէ:

Օրինակ՝ մեծատառ `"A"`-ն հավասար չէ փոքրատառ `"a"`-ին։ Ո՞ր մեկն է մեծ. փոքրատառ `"a"`-ն։ Ինչու՞, քանի որ փոքրատառ նշանը ունի ավելի մեծ ինդեքս կոդավորման աղյուսակում, որն օգտագործում է JavaScript-ը (Unicode)։ Մենք կվերադառնանք սրա մանրամասներին, և բխող հետևանքներին <info:string> բաժնում։
```

## Տարբեր տիպերի համեմատությունը

Երբ համեմատությունը կատարվում է տարբեր տիպերի միջև, JavaScript-ը դրանք ձևափոխում է թվի:

Օրինակ՝

```js run
alert( '2' > 1 ); // true, տողային '2' փոփոխականը ձևափոխվում է թվային 2-ի
alert( '01' == 1 ); // true, տողային '01' փոփոխականը ձևափոխվում է թվային 1-ի
```

Տրամաբանական արժեքների դեպքում `true`-ն ձևափոխվում է `1`-ի, իսկ `false`-ը՝ `0`-ի։ 

Օրինակ՝

```js run
alert( true == 1 ); // true
alert( false == 0 ); // true
```

````smart header="Հետաքրքիր հետևանք"
Միաժամանակ հնարավոր է․

  - Երկու արժեքներ նույնն են։
  - Նրանցից մեկը տրամաբանական `true`-է, իսկ մյուսը տրամաբանական `false`-է։

Օրինակ՝

```js run
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

JavaScript-ի տեսանկյունից, այս արդյունքները համարվում են ճիշտ։ Տողային արժեքը ձևափոխվում է թվային տիպի (ուստի `"0"`-ն ձևափոխվում է `0`-ի), մինչդեռ բացահայտ `Boolean`-փոխակերպումը կիրառում է մեկ այլ կանոն։
````

## Խիստ հավասարություն

Սովորական հավասարության ստուգումը `==` խնդրահարույց է։ Այն չի կարող տարբերակել `0`-ն `false`-ից։

```js run
alert( 0 == false ); // true
```

Նույն բանը կատարվում է դատարկ տողի հետ։

```js run
alert( '' == false ); // true
```

Սա պատահում է, քանի որ `==` գործողությանը տարբեր տիպերի համեմատման ժամանակ արժեքները ձևափոխում է թվերի։ Դատարկ տողը, ինչպես `false`-ը, դառնում է զրո։

Ի՞նչ պետք է անել, եթե ցանկանում ենք տարբերակել `0`-ն `false`-ից։

**Խիստ համեմատության գործողությունը `===` ստուգում է հավասարությունը առանց տիպային կերպափոխումների:**

Այլ կերպ ասած, եթե `a`-ն և `b`-ն տարբերի տիպերի են, ապա `a === b`-ն անմիջապես կվերադարձնի `false`, առանց տիպերի կերպափոխման։

Եկեք փորձենք դա․

```js run
alert(0 === false); // false, քանի որ արժեքները ունեն տարբեր տիպեր
```

Գոյություն ունի "խիստ ոչ հավասար" գործողության նշանը `!==`, որը նման է `!=`-ին։ 

Խիստ հավասարության օպերատորը մի փոքր ավելի երկար է գրվում, բայց ակնհայտ է դառնում այն, որ դա ավելի քիչ է սխալներ առաջացնում։

## Համեմատություն null-ի և undefined-ի հետ

Գոյություն ունի ոչ ինտուիտիվ պահվածք, երբ `null`-ը կամ `undefined`-ը համեմատվում են այլ արժեքների հետ։ 

Խիստ համեմատության `===` դեպքում․
այս արժեքները տարբեր են, քանի որ նրանցից մեկը ունի այլ տիպ

    ```js run
    alert( null === undefined ); // false
    ```

Ոչ խիստ համեմատության `==` դեպքում․
Գոյություն ունի հատուկ կանոն։ Այս երկուսը համահունչ են, դրանք հավասար են իրար հետ, բայց հավասար չեն ոչ արժեքներով։

    ```js run
    alert( null == undefined ); // true
    ```

Մաթեմատիկական և այլհամեմատություններում `< > <= >=`․
`null/undefined`-ը ձևափոխվում են թվերի, `null`-ը ձևափոխվում է `0`-ի, մինչդեռ `undefined`-ը ձևափոխվում է `NaN`-ի։

Այժմ եկեք դիտարկենք մի քանի հետաքրքիր բաներ, որոնք տեղի են ունենում, երբ կիրառում ենք այս կանոնները: Եվ, որ ավելի կարևոր է, ինչպես չնկնել այդ ծուղակը։

### Տարօրինակ արդյունք․ null vs 0

Եկեք համեմատենք `null`-ը զրոյի հետ․

```js run
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) *!*true*/!*
```

Մաթեմատիկորեն, դա տարօրինակ է։ Վերջին արդյունքը, որ «`null`-ը մեծ կամ հավասար է զրոյի», համեմատություններից գոնե մեկը պետք է լինի `true`, բայց երկուսն էլ սխալ են։

Դրա պատճառըն այն է, որ `==` և `> < >= <=` գործողությունները գործում են տարբեր։ Հավասարության ստուգումը կերպափոխում է `null`-ը թվի, այսինքն՝ 0-ի։ Ահա թե ինչու `null >= 0`-ն ճիշտ է, իսկ `null > 0`-ը սխալ։

Մյուս կողմից, `==`-ը ստուգում է `undefined`-ը և `null`-ը առանց ձևափոխման, դրանք հավասար են միմյանց, բայց հավասար չեն այլ փոփոխականի, ահա թե ինչու `null == 0` արտահայտությունը արժեքը `false` է:

### Անհամեմատելի undefined-ը

`undefined` արժեքը չի կարող համեմատվել այլ արժեքների հետ․

```js run
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

Ինչու՞ այն նման չէ զրոյին, համեմատության արդյունքը միշտ կեղծ է:

Մենք ստանում ենք այս արդյունքը, քանի որ․

- Համեմատություններ `(1)`-ը և `(2)`-ը վերադարձնում են `false`, քանի որ `undefined`-ը ձևափոխվում է `NaN`-ի, իսկ `NaN`-ը հատուկ թվային արժեք է, որը բոլոր համեմատությունների դեպքում վերադարձնում է `false`։
- Համեմատություն `(3)`-ը վերադարձնում է `false`, քանի որ `undefined`-ը հավասար է միայն `null`-ին և `undefined`-ին, և ոչ մի այլ արժեքի:

### Խուսափեք խնդիրներից

Ինչու՞ դիտարկեցինք այս օրինակները: Պե՞տք է անընդհատ հիշել այս առանձնահատկությունները: Դե, իրականում ոչ: Փաստորեն, նմանատիպ բարդությունները ժամանակի ընթացքում աստիճանաբար հայտնի կդառնան, բայց այդ խնդիրներից խուսափելու հնարավոր միջոցներ կան.

- Ցանկացած համեմատությանը `undefined/null`-ի հետ, բացի խիստ հավասարությունից, հարկավոր է հատուկ ուշադրություն։
- Մի օգտագործեք `>= > < <=` համեմատությունները այն արժեքների հետ, որոնք կարող են լինել `null/undefined`, եթե իսկապես վստահ չեք, թե ինչ եք անում։ Եթե փոփոխականը կարող է ունենալ այս արժեքները, ստուգեք դրանք առանձին:

## Ամփոփում

- Համեմատման գործողությունները վերադարձնում են տրամաբանական արժեք:
- Տողերը համեմատվում են տառ առ տառ, բառարանային հերթականությամբ:
- Երբ տարբեր տիպեր ունեցող արժեքները համեմատվում են, դրանք ձևափոխվում են թվերի (բացառությամբ խիստ հավասարության համեմատության):
- `null` և `undefined` արժեքները հավասար են (`==`) մեկը մյուսին և հավասար չեն որևէ այլ արժեքի:
- Զգուշացեք օգտագործել այնպիսի համեմատություններ ինչպիսիք են `>`, կամ `<` այն փոփոխականների հետ, որոնք կարող են լինել `null/undefined`։ Լավ գաղափար է `null/undefined`-ը ստուգել առանձին։