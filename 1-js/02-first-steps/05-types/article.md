# Տվյալների տիպերը

JavaScript-ում արժեքը միշտ պատկանում է տվյալների որոշակի տիպի։ Օրինակ՝ տող (string) կամ թիվ (number)։

JavaScript-ում կան տվյալների ութ հիմնական տիպեր։ Այս գլխում մենք կանրադառնանք դրանց մասնակիորեն, իսկ հաջորդ գլուխներում կխոսենք դրանցից յուրաքանչյուրի մասին ավելի մանրամասն։

Փոփոխականը կարող է պարունակել ցանկացած տիպի տվյալ։ Օրինակ՝ սկզբում այն կարող է պարունակել տող (string), իսկ հետո՝ փոխարինվել թվով (number)․

```js
// Սխալ չկա
let message = "բարև";
message = 123456;
```

Այն լեզուները, որոնք թույլ են տալիս նման պահվածք, կոչվում են «դինամիկ տիպավորված»։ Դա նշանակում է, որ տիպերը գոյություն ունեն, բայց փոփոխականները կապված չեն դրանցից ոչ մեկի հետ։

## Թիվ (Number)

```js
let n = 123;
n = 12.345;
```

*number* տիպը ներկայացնում է ինչպես ամբողջ թվերը, այնպես էլ տասնորդական թվերը։

Թվերի համար գոյություն ունեն բազմաթիվ գործողություններ, օրինակ՝ բազմապատկում `*`, բաժանաում `/`, գումարում `+`, հանում `-` և այլն.

Բացի սովորական թվերից կան նաև այսպես կոչված «հատուկ թվային արժեքներ», որոնք նույնպես պատկանում են այս տվյալների տիպին․ `Infinity`, `-Infinity` և `NaN`։

- `Infinity`-ն ներկայացնում է մաթեմատիկական [անվերջությունը](https://hy.wikipedia.org/wiki/%D4%B1%D5%B6%D5%BE%D5%A5%D6%80%D5%BB%D5%B8%D6%82%D5%A9%D5%B5%D5%B8%D6%82%D5%B6_(%D5%B4%D5%A1%D5%A9%D5%A5%D5%B4%D5%A1%D5%BF%D5%AB%D5%AF%D5%A1)) ∞։ Այն հատուկ արժեք է, որը մեծ է ցանկացած թվից։

    Մենք կարող ենք ստանալ այն որպես զրոյի վրա բաժանման արդյունք,

    ```js run
    alert( 1 / 0 ); // Infinity
    ```

    կամ վերցնելով այն ակնհայտ կերպով։

    ```js run
    alert( Infinity ); // Infinity
    ```
- `NaN`-ը նշանակում է հաշվողական սխալ։ Այն սխալ կամ անորոշ մաթեմատիկական գործողույան արդյունք է, օրինակ․

    ```js run
    alert( "ոչ թվային արժեք" / 2 ); // NaN, բաժանումը հնարավոր չէ
    ```

    `NaN`-ը անփոփոխ արժեք է։ Ցանկացած գործողություն `NaN`-ի հետ վերադարձնում է `NaN`:

    ```js run
    alert( NaN + 1 ); // NaN
    alert( 3 * NaN ); // NaN
    alert( "ոչ թվային արժեք" / 2 - 1 ); // NaN
    ```

    Եթե մաթեմատիկական արտահայտության որևէ անդամ `NaN` է, ապա ամբողջ արտահայտության արդյունքը կլինի `NaN`։ Միակ բացառությունը `NaN ** 0` = `1` է։

```smart header="Մաթեմատիկական գործողությունները անվտանգ են"
Մաթեմատիկական գործողությունները JavaScript-ում «անվտանգ» են։ Մենք կարող ենք կատարել ցանկացած գործողություն՝ բաժանել զրոյի, ոչ թվային տողերի հետ վարվել ինչպես թվերի հետ։

Սկրիպտը երբեք կանգ չի առնի՝ շպրտելով սխալ։ Վատագույն դեպքում, որպես արդյունք, մենք կստանանք `NaN`։
```

Հատուկ թվային արժեքները պատկանում են «թիվ» (number) տիպին։ Իրականում դրանք թվեր չեն բառի ուղիղ իմաստով:

Թվերի հետ աշխատանքին ավելի մանրամասն կծանոթանանք <info:number> գլխում։

## BigInt [#bigint-type]

JavaScript-ում «number» տիպը չի կարող ներկայացնել թվային արժեքներ, որոնք մեծ են <code>(2<sup>53</sup>-1)</code>-ից (նույնն է, ինչ `9007199254740991`), կամ փոքր են <code>-(2<sup>53</sup>-1)</code>-ից՝ բացասական թվերի դեպքում։

Իսկապես ճշգրիտ լինելու համար, «number» տիպը կարող է պահել ավելի մեծ ամբողջ թվեր (մինչև <code>1.7976931348623157 * 10<sup>308</sup></code>), բայց անվտանգ ամբողջ թվերի միջակայքից դուրս <code>±(2): <sup>53</sup>-1)</code> ճշգրտության սխալ կլինի, քանի որ ոչ բոլոր թվանշաններն են տեղավորվում ֆիքսված 64-բիթանոց պահեստում: Այնպես որ, «մոտավոր» արժեք կարող է պահվել:

Օրինակ, այս երկու թվերը (անվտանգ տիրույթից անմիջապես վերև) նույնն են.

```js
console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
```

Այսպես ասած՝ <code>(2<sup>53</sup>-1)</code>-ից մեծ բոլոր կենտ ամբողջ թվերն ընդհանրապես չեն կարող պահվել «number» տիպում։

Շատ նպատակների համար <code>±(2<sup>53</sup>-1)</code> միջակայքը բավական է, բայց երբեմն մեզ անհրաժեշտ է իսկապես մեծ ամբողջ թվերի ամբողջ միջակայքը, օրինակ. գաղտնագրության կամ միկրովայրկյանային ճշգրտությամբ ժամանակի համար:

`BigInt`-ը վերջերս է ավելացվել լեզվում՝ կամայական մեծության թվեր նեկայացնելու նպատակով։

`BigInt` արժեք ստեղծվում է թվին վերջից կցելով `n`․

```js
// «n»-ը վերջում նշանակում է, որ արժեքը BigInt տիպի է
const bigInt = 1234567890123456789012345678901234567890n;
```

Քանի որ `BigInt` թվերը հազվադեպ են օգտագործվում, դրանց այստեղ չենք անդրադառնա, այլ կդիտարկենք առանձին՝ <info:bigint> գլխում։ Կարդացե՛ք այն, եթե նման մեծ թվերի օգտագոծման կարիք կունենաք։


```smart header="Համատեղելիության խնդիրներ"
Այս պահին `BigInt`-ը համատեղելի է Firefox/Chrome/Edge/Safari զննիչների հետ, բայց ոչ IE-ի։
```

Կարող եք ստուգել [*MDN* BigInt compatibility table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility) հոդվածը, հասկանալու համար, թե զննիչների որ տարբերակների հետ է այն համատեղելի։

## Տող (String)

JavaScript-ում տողը պետք է շրջապատված լինի չակերտներով։

```js
let str = "Բարև";
let str2 = 'Եզակի չակերտները նույպես թույլատրելի են';
let phrase = `թեք չակերտները կարող են ներառել փոփոխականներ ${str}`;
```

JavaScript-ում գոյություն ոնեն 3 տեսակի չակերտներ.

1. Կրկնակի չակերտներ․ `"Բարև"`։
2. Եզակի չակերտներ․ `'Բարև'`։
3. Թեք չակերտներ․ <code>&#96;Բարև&#96;</code>։

Կրկնակի և եզակի չակերտները «պարզ» չակերտներ են։ JavaScript-ում դրանց միջև տարբերություններ չկան։

Թեք չակերտները ունեն «ընդլայնված ֆունկցիոնալություն»։ Դրանք թույլ են տալիս ներդնել փոփոխականներ և արտահայտություններ տողի մեջ՝ դրանք `${…}`-ի մեջ պարփակելու միջոցով, օրինակ․

```js run
let name = "Դավիթ";

// ներդնենք փոփոխականը
alert( `Բարև, *!*${name}*/!*!` ); // Բարև, Դավիթ!

// ներդնենք արտահայտություն
alert( `արդյունքը կլինի *!*${1 + 2}*/!*` ); // արդյունքը կլինի 3
```

`${…}`-ի մեջ ներդրված արտահայտությունը գնահատվում է, և արդյունքը դառնում է տողի մի մասը։ Մենք կարող ենք տեղադրել այնտեղ ամեն ինչ՝ փոփոխական (`name`) կամ թվաբանական արտահայտություն՝ `1 + 2`-ի նման կամ ավելի բարդ։

Ուշադրություն դարձրեք այն փաստին, որ սա հնարավոր է միայն թեք չակերտների դեպքում։ Մյուս չակերտները չունեն այսպիսի ներդրման ֆունկցիոնալություն։

```js run
alert( "արդյունքը կլինի ${1 + 2}" ); // արդյունքը կլինի ${1 + 2} (կրկնակի չակերտները ոչինչ չեն անում)
```

Մենք կանրադառնանք տողերին ավելի մանրամասն <info:string> գլխում։

```smart header="Գոյություն չունի *character* տիպ։"
Որոշ լեզուներում գոյություն ունի հատուկ "character" տիպ եզակի սիմվոլների համար։ Օրինակ՝ C և Java լեզուներում այն կոչվում է «char»։

JavaScript-ում չկա նման տիպ։ Կա միայն մեկ տիպ՝ `string`։ string-ը կարող է լինել դատարկ, ունենալ մեկ կամ բազմաթիվ նիշեր։
```

## Boolean (տրամաբանական տիպ)

Boolean տիպը ունի երկու արժեք․ `true` և `false`։

Այս տիպը հիմնականում օգտագործվում է այո/ոչ արժեքներ պահելու համար․ `true` նշանակում է «այո, ճիշտ է», իսկ `false` նշանակում է «ոչ, սխալ է»։

Օրինակ՝

```js
let nameFieldChecked = true; // այո, անվանական դաշտը ստուգված է
let ageFieldChecked = false; // ոչ, տարիքային դաշտը ստուգված չէ
```

Boolean արժեքները ստացվում են նաև որպես համեմատությունների արդյունք․

```js run
let isGreater = 4 > 1;

alert( isGreater ); // true (համեմատության արդյունքն է «այո»)
```

Մենք կանրադառնանք boolean տիպին ավելի մանրամասն <info:logical-operators> գլխում։

## «null» արժեքը

`null` հատուկ արժեքը չի պատկանում վերոնշյալ տիպերից ոչ մեկին։

Այն ձևավորում է առանձին տիպ, որը պարունակում է `null` արժեքը:

```js
let age = null;
```

JavaScript-ում `null`-ը «գոյություն չունեցող օբյեկտի հղում» կամ «զրոյական ցուցիչ» չէ, ինչպես որոշ այլ լեզուներում։

Այն պարզապես հատուկ արժեք է, որը նշանակում է «ոչինչ», «դատարկություն» կամ «անհայտ արժեք»։

Վերոնշյալ կոդը պնդում է, որ `age` փոփոխականի արժեքը անհայտ է։

## «undefined» արժեքը

`undefined` հատուկ արժեքը նույնպես ուրույն է։ Այն ձևավորում է իր սեփական տիպը, ճիշտ ինչպես `null`-ը։

`undefined` նշանակում է, որ «արժեք չի վերագրվել»։

Եթե փոփոխականը հայտարարված է, բայց նրան արժեք չի վերագրվել, ապա նրա արժեքը կլինի `undefined`․

```js run
let age;

alert(age); // ցույց կտա «undefined»
```

Տեխնիկապես փոփոխականին հնարավոր է ակնհայտ կերպով վերագրել `undefined` արժեքը․

```js run
let age = 100;

// արժեքը դարձնել «undefined»
age = undefined;

alert(age); // «undefined»
```

...Բայց խորհուրդ չի տրվում այդպես անել։ Սովորաբար `null`-ը օգտագործվում է փոփոխականին «դատարկ» կամ «անհայտ» արժեք վերագրելու համար, մինչդեռ `undefined`-ը  իրենից ենթադրում է նախնական լռելյայն (default) արժեք՝ չվերագրված փոփոխականների համար։

## Օբյեկտներ և սիմվոլներ

`object` տիպը յուրահատուկ է։

Մնացած բոլոր տիպերը կոչվում են «պրիմիտիվ» տիպեր, քանի որ նրանց արժեքները պարզ արժեքներ են (լինի այն տող, թիվ կամ այլ արժեք)։ Օբյեկտները, իրենց հերթին, օգտագործվում են տվյալների համախումբ և ավելի բարդ կառուցվածքներ պահեստավորելու նպատակով։

Օբյեկտները լեզվում կարևոր տեղ են զբաղեցնում և հատուկ ուշադրության են արժանի։ Մենք կզբաղվենք դրանցով ավելի ուշ՝ <info:object> գլխում՝ պրիմիտիվ տիպերը ավելի խորը ուսումնասիրելուց հետո։

`symbol` տիպը օգտագործվում է օբյեկտներում չկրկնվող նույնացուցիչներ ստեղծելու համար։ Մենք այստեղ նշում ենք դրա գոյության փաստը՝ տիպերի նկարագիրը լիարժեք դարձնելու համար, բայց թողնում ենք դրա ուսումնասիրությունը հետագայի համար, երբ արդեն ուսումնասիրած կլինենք օբյեկտները։

## typeof օպերատորը [#type-typeof]

`typeof` օպերատորը վերադարձնում է իր արգումենտի տիպը։ Այն օգտակար է, երբ մենք ուզում ենք մշակել տարբեր տիպերի արժեքները տարբեր կերպով, կամ պարզեպես արագ ստուգման կարիք կա։

`typeof x`-ի կանչը վերադարձնում է տող, որը պարունակում է տիպի անվանումը․

```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

*!*
typeof Math // "object"  (1)
*/!*

*!*
typeof null // "object"  (2)
*/!*

*!*
typeof alert // "function"  (3)
*/!*
```

Վերջին երեք տողերը ունեն հավելյալ պարզաբանման կարիք․

1. `Math`-ը ներկառուցված օբյեկտ է, որը տրամադրում է մաթեմատիկական տարբեր գործողություններ և հաստատուններ։ Մենք կուսումնասիրենք այն <info:number> գլխում։ Այստեղ այն պարզապես ծառայում է որպես օբյեկտի օրինակ։
2. `typeof null`-ի արդյունքը `"object"` է։ Այն `typeof` օպերատորի վարքագծի պաշտոնապես ընդունված սխալ է, որը եկել է JavaScript-ի ստեղծման վաղ ժամանակներից և մնացել է լեզվում համատեղելիության նպատակով։ Անշուշտ, `null`-ը օբյեկտ չէ։ Այն հատուկ արժեք է, որը ունի իր սեփական տիպը։
3. `typeof alert`-ի արդյունքը `"function"` է, քանի որ `alert`-ը ֆունկցիա է։ Մենք կուսումնասիրենք ֆունկցիաները հաջորդ գլուխներում, որտեղ կիմանանք, որ JavaScript-ը չունի առանձին function տիպ։ Ֆունկցիաները պատկանում են object տիպին։ Բայց `typeof`-ը մշակում է դրանք հատուկ ձևով՝ վերադարձնելով `"function"` արժեքը։ Դա նույնպես գալիս է JavaScript-ի պատմության վաղ ժամանակներից։ Տեխնիկապես վարքագիծը ճիշտ չէ, բայց պրակտիկայում կարող է հարմար լինել։

```smart header="The `typeof(x)` syntax"
You may also come across another syntax: `typeof(x)`. It's the same as `typeof x`.

To put it clear: `typeof` is an operator, not a function. The parentheses here aren't a part of `typeof`. It's the kind of parentheses used for mathematical grouping.

Usually, such parentheses contain a mathematical expression, such as `(2 + 2)`, but here they contain only one argument `(x)`. Syntactically, they allow to avoid a space between the `typeof` operator and its argument, and some people like it.

Some people prefer `typeof(x)`, although the `typeof x` syntax is much more common.
```

## Ամփոփում

JavaScript-ում գոյություն ունեն տվյալների 8 տիպեր։

- Տվյալների յոթ պրիմիտիվ տիպեր՝
    - `number` բոլոր տեսակի թվերի համար․ ամբողջ և տասնորդական, ամբողջ թվերը սահմանափակված են <code>±(2<sup>53</sup>-1)</code> միջակայքում։
    - `bigint` կամայական մեծության ամբողջ թվերի համար։
    - `string` տողերի համար։ Տողը կարող է պարունակել զրո կամ ավել նիշեր, չկա նիշի համար նախատեսված առանձին տիպ։
    - `boolean` `true`/`false` արժեքների համար։
    - `null` անհայտ արժեքների համար․ առանձին տիպ է, որը ունի մեկ արժեք՝ `null`։
    - `undefined` չվերագրված արժեքների համար․ առանձին տիպ է, որը ունի մեկ արժեք՝ `undefined`։
    - `object` ավելի բարդ տվյալների կառուցվածքների համար։
    - `symbol` չկրկնվող նույնացուցիչների համար։
- Եվ տվյալների ոչ պրիմիտիվ մեկ տիպ՝
    - `object` տվյալների բարդ կառուցվածքների համար։

`typeof`-ը թույլ է տալիս ստուգել, թե ինչ տիպի արժեք է պահված փոփոխականում։

- Ունի երկու ձև․ `typeof x` կամ `typeof(x)`։
- Վերադարձնում է տող, որը պարունակում է տիպի անվանումը, օրինակ՝ `"string"`։
- `null`-ի դեպքում վերադարձնում է `"object"`․ սա լեզվի սխալ է, այն իրականում օբյեկտ չէ։

Հաջորդ գլուխներում մենք կկենտրոնանանք պրիմիտիվ արժեքների վրա և երբ ծանոթանանք դրանց հետ, կանցնենք օբյեկտների ուսումնասիրությանը։
