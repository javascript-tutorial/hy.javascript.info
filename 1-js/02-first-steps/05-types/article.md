# Տվյալների տիպերը

JavaScript-ում արժեքը միշտ պատկանում է տվյալների որոշակի տիպի։ Օրինակ՝ տող (string) կամ թիվ (number)։

JavaScript-ում կան տվյալների ութ հիմնական տիպեր։ Այս գլխում մենք կանրադառնանք դրանց մասնակիորեն, իսկ հաջորդ գլուխներում կխոսենք դրանցից յուրաքանչյուրի մասին ավելի մանրամասն։

Փոփոխականը կարող է պարունակել ցանկացած տիպի տվյալ։ Օրինակ՝ սկզբում այն կարող է պարունակել տող (string), իսկ հետո՝ փոխարինվել թվով (number)․

```js
// Սխալ չկա
let message = "բարև";
message = 123456;
```

Այն լեզուները, որոնք թույլ են տալիս նման պահվածք, կոչվում են «դինամիկ տիպավորված»։ Դա նշանակում է, որ տիպերը գոյություն ունեն, բայց փոփոխականները կապված չեն դրանցից ոչ մեկի հետ։

## Թիվ (Number)

```js
let n = 123;
n = 12.345;
```

*number* տիպը ներկայացնում է ինչպես ամբողջ թվերը, այնպես էլ տասնորդական թվերը։

Թվերի համար գոյություն ունեն բազմաթիվ գործողություններ, օրինակ՝ բազմապատկում `*`, բաժանաում `/`, գումարում `+`, հանում `-` և այլն.

Բացի սովորական թվերից կան նաև այսպես կոչված «հատուկ թվային արժեքներ», որոնք նույնպես պատկանում են այս տվյալների տիպին․ `Infinity`, `-Infinity` և `NaN`։

- `Infinity`-ն ներկայացնում է մաթեմատիկական [անվերջությունը](https://hy.wikipedia.org/wiki/%D4%B1%D5%B6%D5%BE%D5%A5%D6%80%D5%BB%D5%B8%D6%82%D5%A9%D5%B5%D5%B8%D6%82%D5%B6_(%D5%B4%D5%A1%D5%A9%D5%A5%D5%B4%D5%A1%D5%BF%D5%AB%D5%AF%D5%A1)) ∞։ Այն հատուկ արժեք է, որը մեծ է ցանկացած թվից։

    Մենք կարող ենք ստանալ այն որպես զրոյի վրա բաժանման արդյունք,

    ```js run
    alert( 1 / 0 ); // Infinity
    ```

    կամ վերցնելով այն ակնհայտ կերպով։

    ```js run
    alert( Infinity ); // Infinity
    ```
- `NaN`-ը նշանակում է հաշվողական սխալ։ Այն սխալ կամ անորոշ մաթեմատիկական գործողույան արդյունք է, օրինակ․

    ```js run
    alert( "ոչ թվային արժեք" / 2 ); // NaN, բաժանումը հնարավոր չէ
    ```

    `NaN`-ը անփոփոխ արժեք է։ Ցանկացած գործողություն `NaN`-ի հետ վերադարձնում է `NaN`:

    ```js run
    alert( "ոչ թվային արժեք" / 2 + 5 ); // NaN
    ```

    Եթե մաթեմատիկական արտահայտության որևէ անդամ `NaN` է, ապա ամբողջ արտահայտության արդյունքը կլինի `NaN`։

```smart header="Մաթեմատիկական գործողությունները անվտանգ են"
Մաթեմատիկական գործողությունները JavaScript-ում «անվտանգ» են։ Մենք կարող ենք կատարել ցանկացած գործողություն՝ բաժանել զրոյի, ոչ թվային տողերի հետ վարվել ինչպես թվերի հետ։

Սկրիպտը երբեք կանգ չի առնի՝ շպրտելով սխալ։ Վատագույն դեպքում, որպես արդյունք, մենք կստանանք `NaN`։
```

Հատուկ թվային արժեքները պատկանում են «թիվ» (number) տիպին։ Իրականում դրանք թվեր չեն բառի ուղիղ իմաստով:

Թվերի հետ աշխատանքին ավելի մանրամասն կծանոթանանք <info:number> գլխում։

## BigInt [#bigint-type]

JavaScript-ում թվային (number) տիպը չի կարող ներկայացնել թվային արժեքներ, որոնք մեծ են <code>(2<sup>53</sup>-1)</code>-ից (նույնն է, ինչ `9007199254740991`), կամ փոքր են <code>-(2<sup>53</sup>-1)</code>-ից՝ բացասական թվերի դեպքում։ Այս տեխիկական սահմանափակումը պայմանավորված է թվերի ներքին ներկայացման յուրահատկություններով։

Հիմնական դեպքերում սա ավելի քան բավական է, բայց երբեմն մենք կարիք ենք ունենում օգտագործելու իսկապես մեծ թվեր, օրինակ՝ գաղտնագրման կամ ժամանականիշի (timestamp) միկրովարկյաններով ներկայացման դեպքում։

`BigInt`-ը վերջերս է ավելացվել լեզվում՝ կամայական մեծության թվեր նեկայացնելու նպատակով։

`BigInt` արժեք ստեղծվում է թվին վերջից կցելով `n`․

```js
// «n»-ը վերջում նշանակում է, որ արժեքը BigInt տիպի է
const bigInt = 1234567890123456789012345678901234567890n;
```

Քանի որ `BigInt` թվերը հազվադեպ են օգտագործվում, դրանց այստեղ չենք անդրադառնա, այլ կդիտարկենք առանձին՝ <info:bigint> գլխում։ Կարդացե՛ք այն, եթե նման մեծ թվերի օգտագոծման կարիք կունենաք։


```smart header="Համատեղելիության խնդիրներ"
Այս պահին `BigInt`-ը համատեղելի է Firefox/Chrome/Edge/Safari զննիչների հետ, բայց ոչ IE-ի։
```

Կարող եք ստուգել [*MDN* BigInt compatibility table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility) հոդվածը, հասկանալու համար, թե զննիչների որ տարբերակների հետ է այն համատեղելի։

## Տող (String)

JavaScript-ում տողը պետք է շրջապատված լինի չակերտներով։

```js
let str = "Բարև";
let str2 = 'Եզակի չակերտները նույպես թույլատրելի են';
let phrase = `թեք չակերտները կարող են ներառել փոփոխականներ ${str}`;
```

JavaScript-ում գոյություն ոնեն 3 տեսակի չակերտներ.

1. Կրկնակի չակերտներ․ `"Բարև"`։
2. Եզակի չակերտներ․ `'Բարև'`։
3. Թեք չակերտներ․ <code>&#96;Բարև&#96;</code>։

Կրկնակի և եզակի չակերտները «պարզ» չակերտներ են։ JavaScript-ում դրանց միջև տարբերություններ չկան։

Թեք չակերտները ունեն «ընդլայնված ֆունկցիոնալություն»։ Դրանք թույլ են տալիս ներդնել փոփոխականներ և արտահայտություններ տողի մեջ՝ դրանք `${…}`-ի մեջ պարփակելու միջոցով, օրինակ․

```js run
let name = "Դավիթ";

// ներդնենք փոփոխականը
alert( `Բարև, *!*${name}*/!*!` ); // Բարև, Դավիթ!

// ներդնենք արտահայտություն
alert( `արդյունքը կլինի *!*${1 + 2}*/!*` ); // արդյունքը կլինի 3
```

`${…}`-ի մեջ ներդրված արտահայտությունը գնահատվում է, և արդյունքը դառնում է տողի մի մասը։ Մենք կարող ենք տեղադրել այնտեղ ամեն ինչ՝ փոփոխական (`name`) կամ թվաբանական արտահայտություն՝ `1 + 2`-ի նման կամ ավելի բարդ։

Ուշադրություն դարձրեք այն փաստին, որ սա հնարավոր է միայն թեք չակերտների դեպքում։ Մյուս չակերտները չունեն այսպիսի ներդրման ֆունկցիոնալություն։

```js run
alert( "արդյունքը կլինի ${1 + 2}" ); // արդյունքը կլինի ${1 + 2} (կրկնակի չակերտները ոչինչ չեն անում)
```

Մենք կանրադառնանք տողերին ավելի մանրամասն <info:string> գլխում։

```smart header="Գոյություն չունի *character* տիպ։"
Որոշ լեզուներում գոյություն ունի հատուկ "character" տիպ եզակի սիմվոլների համար։ Օրինակ՝ C և Java լեզուներում այն կոչվում է «char»։

JavaScript-ում չկա նման տիպ։ Կա միայն մեկ տիպ՝ `string`։ string-ը կարող է լինել դատարկ, ունենալ մեկ կամ բազմաթիվ նիշեր։
```

## Boolean (տրամաբանական տիպ)

Boolean տիպը ունի երկու արժեք․ `true` և `false`։

Այս տիպը հիմնականում օգտագործվում է այո/ոչ արժեքներ պահելու համար․ `true` նշանակում է «այո, ճիշտ է», իսկ `false` նշանակում է «ոչ, սխալ է»։

Օրինակ՝

```js
let nameFieldChecked = true; // այո, անվանական դաշտը ստուգված է
let ageFieldChecked = false; // ոչ, տարիքային դաշտը ստուգված չէ
```

Boolean արժեքները ստացվում են նաև որպես համեմատությունների արդյունք․

```js run
let isGreater = 4 > 1;

alert( isGreater ); // true (համեմատության արդյունքն է «այո»)
```

Մենք կանրադառնանք boolean տիպին ավելի մանրամասն <info:logical-operators> գլխում։

## «null» արժեքը

`null` հատուկ արժեքը չի պատկանում վերոնշյալ տիպերից ոչ մեկին։

Այն ձևավորում է առանձին տիպ, որը պարունակում է `null` արժեքը:

```js
let age = null;
```

JavaScript-ում `null`-ը «գոյություն չունեցող օբյեկտի հղում» կամ «զրոյական ցուցիչ» չէ, ինչպես որոշ այլ լեզուներում։

Այն պարզապես հատուկ արժեք է, որը նշանակում է «ոչինչ», «դատարկություն» կամ «անհայտ արժեք»։

Վերոնշյալ կոդը պնդում է, որ `age` փոփոխականի արժեքը անհայտ է։

## «undefined» արժեքը

`undefined` հատուկ արժեքը նույնպես ուրույն է։ Այն ձևավորում է իր սեփական տիպը, ճիշտ ինչպես `null`-ը։

`undefined` նշանակում է, որ «արժեք չի վերագրվել»։

Եթե փոփոխականը հայտարարված է, բայց նրան արժեք չի վերագրվել, ապա նրա արժեքը կլինի `undefined`․

```js run
let age;

alert(age); // ցույց կտա «undefined»
```

Տեխնիկապես փոփոխականին հնարավոր է ակնհայտ կերպով վերագրել `undefined` արժեքը․

```js run
let age = 100;

// արժեքը դարձնել «undefined»
age = undefined;

alert(age); // «undefined»
```

...Բայց խորհուրդ չի տրվում այդպես անել։ Սովորաբար `null`-ը օգտագործվում է փոփոխականին «դատարկ» կամ «անհայտ» արժեք վերագրելու համար, մինչդեռ `undefined`-ը  իրենից ենթադրում է նախնական լռելյայն (default) արժեք՝ չվերագրված փոփոխականների համար։

## Օբյեկտներ և սիմվոլներ

`object` տիպը յուրահատուկ է։

Մնացած բոլոր տիպերը կոչվում են «պրիմիտիվ» տիպեր, քանի որ նրանց արժեքները պարզ արժեքներ են (լինի այն տող, թիվ կամ այլ արժեք)։ Օբյեկտները, իրենց հերթին, օգտագործվում են տվյալների համախումբ և ավելի բարդ կառուցվածքներ պահեստավորելու նպատակով։

Օբյեկտները լեզվում կարևոր տեղ են զբաղեցնում և հատուկ ուշադրության են արժանի։ Մենք կզբաղվենք դրանցով ավելի ուշ՝ <info:object> գլխում՝ պրիմիտիվ տիպերը ավելի խորը ուսումնասիրելուց հետո։

`symbol` տիպը օգտագործվում է օբյեկտներում չկրկնվող նույնացուցիչներ ստեղծելու համար։ Մենք այստեղ նշում ենք դրա գոյության փաստը՝ տիպերի նկարագիրը լիարժեք դարձնելու համար, բայց թողնում ենք դրա ուսումնասիրությունը հետագայի համար, երբ արդեն ուսումնասիրած կլինենք օբյեկտները։

## typeof օպերատորը [#type-typeof]

`typeof` օպերատորը վերադարձնում է իր արգումենտի տիպը։ Այն օգտակար է, երբ մենք ուզում ենք մշակել տարբեր տիպերի արժեքները տարբեր կերպով, կամ պարզեպես արագ ստուգման կարիք կա։

<<<<<<< HEAD
Այն ունի օգտագործման երկու շարահյուսություն (syntax)․

1. Որպես օպերատոր՝ `typeof x`։
2. Որպես ֆունկցիա `typeof(x)`։

Այլ կերպ ասած, այն աշխատում է և՛ փակագծերով, և՛ առանց դրանց։ Արդյունքը նույնն է։

`typeof x`-ի կանչը վերադարձնում է տող, որը պարունակում է տիպի անվանումը․
=======
A call to `typeof x` returns a string with the type name:
>>>>>>> 246c600f11b4e6c52b4ae14f83e65319671f998f

```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

*!*
typeof Math // "object"  (1)
*/!*

*!*
typeof null // "object"  (2)
*/!*

*!*
typeof alert // "function"  (3)
*/!*
```

Վերջին երեք տողերը ունեն հավելյալ պարզաբանման կարիք․

<<<<<<< HEAD
1. `Math`-ը ներկառուցված օբյեկտ է, որը տրամադրում է մաթեմատիկական տարբեր գործողություններ և հաստատուններ։ Մենք կուսումնասիրենք այն <info:number> գլխում։ Այստեղ այն պարզապես ծառայում է որպես օբյեկտի օրինակ։
2. `typeof null`-ի արդյունքը `"object"` է։ Այն `typeof` օպերատորի վարքագծի պաշտոնապես ընդունված սխալ է, որը եկել է JavaScript-ի ստեղծման վաղ ժամանակներից և մնացել է լեզվում համատեղելիության նպատակով։ Անշուշտ, `null`-ը օբյեկտ չէ։ Այն հատուկ արժեք է, որը ունի իր սեփական տիպը։
3. `typeof alert`-ի արդյունքը `"function"` է, քանի որ `alert`-ը ֆունկցիա է։ Մենք կուսումնասիրենք ֆունկցիաները հաջորդ գլուխներում, որտեղ կիմանանք, որ JavaScript-ը չունի առանձին function տիպ։ Ֆունկցիաները պատկանում են object տիպին։ Բայց `typeof`-ը մշակում է դրանք հատուկ ձևով՝ վերադարձնելով `"function"` արժեքը։ Դա նույնպես գալիս է JavaScript-ի պատմության վաղ ժամանակներից։ Տեխնիկապես վարքագիծը ճիշտ չէ, բայց պրակտիկայում կարող է հարմար լինել։

## Ամփոփում
=======
1. `Math` is a built-in object that provides mathematical operations. We will learn it in the chapter <info:number>. Here, it serves just as an example of an object.
2. The result of `typeof null` is `"object"`. That's an officially recognized error in `typeof`, coming from very early days of JavaScript and kept for compatibility. Definitely, `null` is not an object. It is a special value with a separate type of its own. The behavior of `typeof` is wrong here.
3. The result of `typeof alert` is `"function"`, because `alert` is a function. We'll study functions in the next chapters where we'll also see that there's no special "function" type in JavaScript. Functions belong to the object type. But `typeof` treats them differently, returning `"function"`. That also comes from the early days of JavaScript. Technically, such behavior isn't correct, but can be convenient in practice.

```smart header="The `typeof(x)` syntax"
You may also come across another syntax: `typeof(x)`. It's the same as `typeof x`.

To put it clear: `typeof` is an operator, not a function. The parentheses here aren't a part of `typeof`. It's the kind of parentheses used for mathematical grouping.

Usually, such parentheses contain a mathematical expression, such as `(2 + 2)`, but here they contain only one argument `(x)`. Syntactically, they allow to avoid a space between the `typeof` operator and its argument, and some people like it.

Some people prefer `typeof(x)`, although the `typeof x` syntax is much more common.
```

## Summary
>>>>>>> 246c600f11b4e6c52b4ae14f83e65319671f998f

JavaScript-ում գոյություն ունեն տվյալների 8 տիպեր։

- `number` բոլոր տեսակի թվերի համար․ ամբողջ և տասնորդական, ամբողջ թվերը սահմանափակված են <code>±(2<sup>53</sup>-1)</code> միջակայքում։
- `bigint` կամայական մեծության ամբողջ թվերի համար։
- `string` տողերի համար։ Տողը կարող է պարունակել զրո կամ ավել նիշեր, չկա նիշի համար նախատեսված առանձին տիպ։
- `boolean` `true`/`false` արժեքների համար։
- `null` անհայտ արժեքների համար․ առանձին տիպ է, որը ունի մեկ արժեք՝ `null`։
- `undefined` չվերագրված արժեքների համար․ առանձին տիպ է, որը ունի մեկ արժեք՝ `undefined`։
- `object` ավելի բարդ տվյալների կառուցվածքների համար։
- `symbol` չկրկնվող նույնացուցիչների համար։

`typeof`-ը թույլ է տալիս ստուգել, թե ինչ տիպի արժեք է պահված փոփոխականում։

<<<<<<< HEAD
- Ունի երկու ձև․ `typeof x` կամ `typeof(x)`։
- Վերադարձնում է տող, որը պարունակում է տիպի անվանումը, օրինակ՝ `"string"`։
- `null`-ի դեպքում վերադարձնում է `"object"`․ սա լեզվի սխալ է, այն իրականում օբյեկտ չէ։
=======
- Usually used as `typeof x`, but `typeof(x)` is also possible.
- Returns a string with the name of the type, like `"string"`.
- For `null` returns `"object"` -- this is an error in the language, it's not actually an object.
>>>>>>> 246c600f11b4e6c52b4ae14f83e65319671f998f

Հաջորդ գլուխներում մենք կկենտրոնանանք պրիմիտիվ արժեքների վրա և երբ ծանոթանանք դրանց հետ, կանցնենք օբյեկտների ուսումնասիրությանը։
