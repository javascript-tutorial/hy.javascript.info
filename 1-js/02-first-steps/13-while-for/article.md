# Ցիկլեր․ while և for

Հաճախ մենք կարիք ենք ունենում կրկնել ինչ֊որ գործողությունների հերթականություն։

Օրինակ․ տպել իրար հետևից ցուցակի մեջ գտնվող ապրանքները, կամ ուղղակի աշխատեցնել նույն կոդը 1֊ից 10 բոլոր թվերի համար։

*Ցիկլերը* նույն կոդը մի քանի անգամ կրկնելու հնարավորություն են տալիս։

```smart header="The for..of and for..in loops"
A small announcement for advanced readers.

This article covers only basic loops: `while`, `do..while` and `for(..;..;..)`.

If you came to this article searching for other types of loops, here are the pointers:

- See [for..in](info:object#forin) to loop over object properties.
- See [for..of](info:array#loops) and [iterables](info:iterable) for looping over arrays and iterable objects.

Otherwise, please read on.
```

## The "while" loop

`while` ցիկլը ունի հետևյալ գրելաձևը․

```js
while (condition) {
  // կոդը
  // որին նաև ասում են "ցիկլի մարմին" ("loop body")
}
```

Քանի դեռ `condition`֊ը (պայմանը) ճշմարիտ է, `կոդը` ցիկլի մարմնի ներսում կկատարվի։

Օրինակի համար, ներքևի ցիկլը կարտածի `i`, քանի դեռ `i < 3`․

```js run
let i = 0;
while (i < 3) { // ցույց կտա 0, հետո 1, հետո 2
  alert( i );
  i++;
}
```

Ցիկլի մարմնի մի կատարումը անվանում են *իտերացիա* (*an iteration*): Ցիկլը վերևի օրինակում կատարում է երեք իտերացիա։

Եթե չլիներ `i++` գործողությունը վերևի օրինակում, ապա ցիկլը կկրկնվեր (տեսականորեն) անվերջ։ Պրակտիկայում, դիտարկիչը (browser) կտրամադրի տարբեր գործիքներ, որոնց միջոցով կկարողանանք կանգնեցնել այդպիսի ցիկլկերը, և սերվերում (server-side) կիրառվող JavaScript֊ում կարող ենք սպանել (kill) այդ պրոցեսը։

Կամայական արտահայտություն կամ փոփոխական կարող է լինել ցիկլի պայման։ Պայմանը հաշվվում և ձևափոխվում է տրամաբանական տիպի `while`֊ի կողմից։

Օրինակի համար, `while (i != 0)` արտահայտության կարճ գրելաձևը կլինի `while (i)`:

```js run
let i = 3;
*!*
while (i) { // երբ i֊ն դառնա 0, պայմանը կդառնա սխալական, և ցիկլը կանգ կառնի
*/!*
  alert( i );
  i--;
}
```

````smart header="Ձևավոր փակագծերը պարտադիր չեն մեկ տողանի մարմնի համար"
Եթե ցիկլի մարմինը ունի ընդամենը մեկ արտահայտություն (statement), ապա կարող ենք բաց թողնել ձևավոր փակագծերը `{…}`․

```js run
let i = 3;
*!*
while (i) alert(i--);
*/!*
```
````

## "do..while" ցիկլը

Պայմանի ստուգումը կարելի է տեղափոխել ցիկլի մարմնի *ներքևը* օգտագործելով `do..while` գերլաձևը․

```js
do {
  // ցիկլի մարմին
} while (condition);
```

Ցիկլը սկզբում կաշխատացնի մարմինը, ապա կստուգի պայմանը, և քանի դեռ այն ճշմարիտ է, այն կաշխատացնի մարմինը նորից ու նորից։

Օրինակ․

```js run
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

Այս գրելաձևը պետք է օգտագործվի միայն այն դեպքում, երբ ցանկանում եք, որ ցիկլի մարմինը աշխատի **առնվազն մեկ անգամ** անկախ պայմանի ճշմարիտ կամ սխալական լինելու փաստից։ Սովորաբար մյուս տեսքը ավելի նախընտրելի է․ `while(…) {…}`։

## "for" ցիկլը

`for` ցիլկը ավելի բարդ է, բայց այն ամենից շատ կիրառվող ցիկլն է։

Այն ունի հետևյալ տեսքը․

```js
for (begin; condition; step) {
  // ... ցիկլի մարմին ...
}
```

Եկեք ուսումնասիրենք այդ մասերը օրինակի վրա։ Ներքևի ցիկլը կատարում է `alert(i)` հրամանը `i`֊ն `0`֊ից մինչև `3`֊ը ոչ ներառյալ:

```js run
for (let i = 0; i < 3; i++) { // ցույց կտա 0, հետո 1, հետո 2
  alert(i);
}
```

Դիտարկենք `for`֊ը մաս առ մաս․

| մաս  |          |                                                                            |
|-------|----------|----------------------------------------------------------------------------|
| սկիզբ | `i = 0`    | Կատարվում է, երբ մտնում ենք ցիկլ։                                      |
| պայման | `i < 3`| Ստուգվում է ցիկլի ամեն իտերացիայից առաջ։ Եթե այն սխալ է, ապա ցիկլը կանգնեցվում է։              |
| մարմին | `alert(i)`| Աշխատում է այնքան ժամանակ, քանի դեռ պայմանը ճշմարիտ է։                         |
| քայլ| `i++`      | Կատարվում է մարմնի կատարումից հետո, ամեն իտերացիայի ժամանակ։ |

Ընդհանուր դեպքում ալգորիթմը աշխատում է հետևյալ կերպ․

```
Աշխատացնել *սկիզբ*
→ (եթե *պայման* → կատարել *մարմին* և աշխատացնել *քայլ*)
→ (եթե *պայման* → կատարել *մարմին* և աշխատացնել *քայլ*)
→ (եթե *պայման* → կատարել *մարմին* և աշխատացնել *քայլ*)
→ ...
```

Այսինքն՝ `սկիզբ`֊ը կատարվում է մեկ անգամ, և հետո սկսվում են իտերացիաները․ ամեն `պայման`֊ի ստուգումից հետո, `մարմին`֊ը և `քայլ`֊ը կատարվում են։

Եթե ցիկլերի թեման նոր է ձեր համար, ապա օգտակար կլինի հետ գնալ օրինակներին և քայլ առ քայլ գրառել դրանց կատարման ընթացքները թղթի վրա։

Ահա թե ինչ է տեղի ունենում կոնկրետ մեր օրինակի դեպքում․

```js
// for (let i = 0; i < 3; i++) alert(i)

// աշխատացնել սկիզբը
let i = 0
// եթե պայման → կատարել մարմինը և աշխատացնել քայլը
if (i < 3) { alert(i); i++ }
// եթե պայման → կատարել մարմինը և աշխատացնել քայլը
if (i < 3) { alert(i); i++ }
// եթե պայման → կատարել մարմինը և աշխատացնել քայլը
if (i < 3) { alert(i); i++ }
// ...ավարտ, քանի որ i == 3
```

````smart header="Փոփոխականի ներկառուցված հայտարարում"
Այստեղ "հաշվիչ" փոփոխական `i`֊ն հայտարարված է հենց ցիկլի վրա։ Այն կոչվում է "ներկառուցված" փոփոխականի հայտարարում։ Այսպիսի փոփոխականները տեսանելի են միայն ցիկլի ներսում։

```js run
for (*!*let*/!* i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // սխալ է, չկա այդպիսի փոփոխական
```

Փոփոխական հայտարարելու փոխարեն մենք կարող ենք օգտագործել արդեն գոյություն ունեցողը։

```js run
let i = 0;

for (i = 0; i < 3; i++) { // օգտագործվում է գոյություն ունեցող փոփոխական
  alert(i); // 0, 1, 2
}

alert(i); // 3, տեսանելի է, քանի որ հայտարարված է ցիկլից դուրս
```
````

### Մասերի բաց թողում

`for` ցիկլի ամեն մաս կաող է բաց թողնվել։

Օրինակ, կարող ենք բաց թողնել `սկիզբ`֊ը, եթե ցիկլի սկզբում գործողություն չունենք անելու։

Ինչպես այստեղ․

```js run
let i = 0; // i֊ն արդեն հայտարարված և արժեք ստացած է

for (; i < 3; i++) { // կարիք չկա "սկիզբ"֊ի
  alert( i ); // 0, 1, 2
}
```

Մենք կարող ենք նաև հեռացնել `քայլ`֊ի հատվածը․

```js run
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
```

Այն դառնում է նույնաբար `while (i < 3)` ցիկլը։

Մենք կարող ենք հեռացնել ամեն բան, և կստանանք անվերջ ցիկլ․

```js
for (;;) {
  // կրկնվում է անվերջ
}
```

Նկատի ունեցեք, որ `for`֊ի երկու կետ ստորակետները `;` պարտադիր պետք է գրված լինեն, հակառակ դեպքում տեղի կունենա սինտաքսի սխալ (syntax error)։

## Ցիկլի ընդհատում (break)

Սովորական դեպքերում ցիկլը դուրս է գալիս (ավարտվում է) այն ժամանակ, երբ նրա պայմանը դառնում է սխալական։

Բայց մենք կարող ենք հարկադրաբար (force) դուրս գալ ցիկլից, ամեն պահի, օգտագործելով հատուկ դիրեկտիվ `break`֊ը։

Օրինակ՝ ներքևի ցիկլը օգտատիրոջից անընդհատ թվային մուտք է ուզում, "ընդհատվում" է, երբ ոչ թվային արժեք է մուտքագրվում․

```js run
let sum = 0;

while (true) {

  let value = +prompt("Մուտքագրեք թիվ", '');

*!*
  if (!value) break; // (*)
*/!*

  sum += value;

}
alert( 'Գումարը՝ ' + sum );
```

`break` դիրեկտիվը կատարվում է `(*)` տողում, եթե օգտատերը մուտքագրում է դատարկ տող կամ չեղարկում է ներմուծման դաշտը։ Այն անմիջապես դադարեցնում է ցիկլը, և փոխանցում կատարումը ցիկլի անմիջապես հաջորդող տողին։ Մեր դեպքում՝ `alert`։

"Անվերջ ցիկլ + `break`" կոմբինացիան հիանալի լուծում է այն դեպքերի համար, երբ ցիկլի պայմանը պետք է ստուգվի ոչ թե սկզբում կամ վերջում, այլ ցիկլի մարմնի մեջ, նույնիսկ կարող է ստուգվել մի քանի տեղ։

## Շարունակել հաջորդ իտերացիայից [#continue]

`continue` դիրեկտիվը `break`֊ի ավելի "թեթև տարբերակն" է։ Այն չի կանգնեցնում ամբողջ ցիկլը, այլ կանգնեցնում է միայն ընթացիկ իտերացիան, և հարկադրում ցիկլին անցնել հաջորդին (եթե պայմանը ճշմարիտ է)։

Մենք կարող ենք օգտագործել այն, եթե այլևս կարիք չկա շարունակել այդ պահի իտերացիան և ցանկանում ենք անցնել հաջորդին։

Ներքևի ցիկլը օգտագործում է `continue`֊ն՝ ցուցադրելու միայն կենտ արժեքները․

```js run no-beautify
for (let i = 0; i < 10; i++) {

  // եթե ճիշտ է, բաց է թողնում ցիկլի մարմնի ներքևի հատվածը
  *!*if (i % 2 == 0) continue;*/!*

  alert(i); // 1, հետո 3, 5, 7, 9
}
```

`i`֊ի զույգ արժեքների համար `continue` դիրեկտիվը կանգնեցնում է մարմնի կատարումը և կատարումը փոխանցում `for`֊ի հաջորդ իտերացիային (հաջորդ թվով)։ Այսպիսով, `alert`֊ը կանչվում է միայն կենտ արժեքների համար։

````smart header="`continue` դիրեկտիվը օգնում է քչացնել ներդրվածությունները"
Ցիկլը, որը ցույց է տալիս միայն կենտ արժեքները կարող էր ունենալ հետևյալ տեսքը․

```js run
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
```

Տեխնիկական տեսանկյունից վերևում բերված երկու օրինակները ամբողջովին նույնն են։ Իհարկե, մենք կարող ենք շրջապատել մեր կոդի այդ հատվածը `if` բլոկով, `continue`֊ի փոխարեն։

Բայց որպես կողմնակի ազդեցություն, սա ստեղծեց բնադրման ևս մեկ մակարդակ (`alert`֊ի կանչը ձևավոր փակագծերի ներսում)։ Եթե `if`֊ի ներսում կոդը մի քանի տողից երկար է, ապա այն կարող է նվազեցնել ընդհանուր ընթեռնելիությունը։
````

````warn header="Ոչ մի `break/continue` '?'֊ի աջ կողմում"
Ուշադրություն դարձրեք, որ սինտաքսիկ կոնդտրուկցիաները (syntax constructs) չեն հանդիսանում արտահայտություններ (expressions) և չեն կարող օգտագործվել `?` օպերատորի հետ։ Մասնավոր դեպքում, `break/continue` և նմանատիպ դիրեկտիվները թույլատրված չեն '?'֊ի հետ։

Օրինակի համար, եթե դիտարկենք այս ծրագիրը․

```js
if (i > 5) {
  alert(i);
} else {
  continue;
}
```

...և ձևափոխենք այն օգտագործելով հարցականի նշանը․

```js no-beautify
(i > 5) ? alert(i) : *!*continue*/!*; // continue֊ն թույլատրված չէ այստեղ
```

...այն կդադարի աշխատել, քանի որ կա սինտաքսի սխալ։

Սա մեկ այլ պատճառ է, որպեսզի չօգտագործենք `?`֊ը `if`֊ի փոխարեն։
````

## Պիտակներ (labels) break֊ի և continue֊ի համար

Կան դեպքեր, երբ մենք ցանկանում ենք դուրս գալ միանգամից մի քանի դերդրված ցիկլերից միանգամից։

Օրինակ, ներքևի ծրագրում մենք անցնում ենք ցիկլ `i` և `j` փոփոխականներով, `prompt`-ի օգնությամբ հարցնում `(i, j)` կոորդինատների համար արժեք, սկսած `(0,0)` մինչև `(2,2)`․

```js run no-beautify
for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Արժեքը (${i},${j}) կոորդինատում`, '');

    // ի՞նչ եթե ցանկանում ենք դուրս գալ այստեղից, և անցնել Պատրաստ է (ներքև) տողին
  }
}

alert('Պատրաստ է!');
```

Մեզ պետք է ինչ֊որ ձև կանգնեցնել պրոցեսը, եթե օգտատերը չեղարկել է ներմուծման դաշտը։

Ստանդարտ `break`֊ը `input`֊ից հետո կկանգնեցնի միայն ներսի ցիկլը։ Դա բավարար չէ, և այստեղ է, որ պիտակները գալիս են օգնության։

*Պիտակը* դա նույնականացուցիչ (identifier) է վերջակետով ցիկլից առաջ․

```js
labelName: for (...) {
  ...
}
```

`break <labelName>` հրամանը ներքևի ցիկլում կանգնեցնում է դրսի ցիկլը և անցնում պիտակի ցիկլի վերջը․

```js run no-beautify
*!*outer:*/!* for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Արժեքը (${i},${j}) կոորդինատում`, '');

    // եթե դատարկ տող է կամ չեղարկված, ապա երկու ցիկլերն էլ կանգնեցվում են
    if (!input) *!*break outer*/!*; // (*)

    // արժեքի հետ ինչ֊որ գործողություն...
  }
}

alert('Պատրաստ է!');
```

Վերևի ծրագրում `break outer`֊ը փնտրում է իրեն ընդգրկող դրսի ցիկլը, որի պիտակը `outer` է, և կանգնեցնում այն։

Այդպիսով կատարումը `(*)`֊ից անցնում է միանգամից `alert('Done!')`։

Մենք նաև կարող ենք պիտակները տեղադրել ուրիշ տողում․

```js no-beautify
outer:
for (let i = 0; i < 3; i++) { ... }
```

`continue` դիրեկտիվը նույնպես կարող է կիրառվել պիտակների հետ։ Այս դեպքում, ծրագրի կատարումը անցնում է նշված պիտակով ցիկլի հաջորդ իտերացիային։

````warn header="Պիտակները թույլ չեն տալիս \"ցատկել\" կամայական տեղ"
Պիտակները թույլ չեն տալիս մեզ ցատկել ծրագրի լրիվ այլ հատված։

Օրինակ, անհնար է անել այսպիրի հնարք․

```js
break label; // ցատկ ներքևի պիտակին (չի աշխատի)

label: for (...)
```

`break` դիրեկտիվը պետք է լինի պիտակը պարունակող բլոկի ներսում։ Տեխնիկապես կամայական պիտակավորված բլոկի համար կարող ենք անել հետևյալը․

```js
label: {
  // ...
  break label; // կաշխատի
  // ...
}
```

...Չնայած դրան, 99.9% դեպքերում `break`֊ը օգտագործվում է ցիկլերի ներսում, ինչպես տեսանք վերևի օրինակում։

`continue`֊ն միայն հնարավոր է կիրառել ցիկլի ներսում։
````

## Ամփոփում

Մենք դիտարկեցինք ցիկլերի 3 տիպ․

- `while` -- Ստուգվում է պայմանը ամեն իտերացիայից առաջ։
- `do..while` -- Ստուգվում է պայմանը ամեն իտերացիայից հետո։
- `for (;;)` -- Ստուգվում է պայմանը ամեն իտերացիայից առաջ, և տալիս լրացուցիչ կարգավորումների հնարավորություն

"Անվերջ" ցիկլ ստանալու համար սովորաբար օգտագործում են `while(true)`։ Այս ցիկլը, ինչպես նաև կամայական այլ ցիկլ, կարող է կանգնեցվել `break` դիրեկտիվի միջոցով։

Եթե մենք չենք ուզում, որ աշխատի ընթացիկ իտերացիան, այլ ցանկանում ենք անցնել հաջորդին, ապա կարող ենք օգտագործել `continue` դիրեկտիվը։

`break/continue` կարող են կիրառվել ցիկլերից առաջ գրված պիտակների վրա։ Պիտակը միակ ձևն է `break/continue`֊ի միջոցով ներդրված ցիկլերից դրսի ցիկլը կանգնեցնելու կամ դրա հաջորդ իտերացիային անցնելու համար։
